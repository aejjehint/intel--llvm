# Implementation design for parallel loop annotations and `ivdep`

This document describes the LLVM and SPIR-V implementation for representing
guarantees about loop-carried memory dependence distance for loops with
parallelism annotations like ivdep.

## Attributes

### Attributes for specifying no loop-carried dependences: `[[intel::ivdep]]` and `[[intel::ivdep(array)]]`

When placed on a kernel loop, these attributes indicate that there are no
loop-carried memory (data) dependences on all pointer and array accesses
(`ivdep`) or on the specified array/pointer (`ivdep(array)`). This annotation
allows the compiler to avoid making conservative assumptions when it cannot
infer the loop-carried dependences on a specific array. For example consider the
following code:

```cpp
for (int i = 0; i < N; ++i) {
   B[i] += B[idx[i]];
}
```

Since the access `B[idx[i]]` is unknown at compile time, the compiler will have
to make the conservative assumption that there is a loop carried dependence of
distance 1 between the write to B and the read from B (in both directions) of it
tries to parallelize the loop. If however `ivdep` is used, then the annotation
tells the compiler that there are no loop-carried dependences on `B`, and the
compiler can make parallelism decisions without this assumption.

```cpp
[[intel::ivdep]]
for (int i = 0; i < N; ++i) {
   B[i] += B[idx[i]];
}
```

### Attributes for specifying loop-carried dependence distance: `[[intel::ivdep(safelen)]]` and `[[intel::ivdep(array,safelen)]]`

When placed on a loop, these attributes indicate that any loop-carried
dependences on all pointer and array accesses (`ivdep(safelen)`) or on the
specified array/pointer (`ivdep(array,safelen)`) have a distance of at least
`safelen`. This can be used to disambiguate any aliasing when the compiler
cannot automatically infer the dependence distance and instead has to make the
conservative assumption that the distance is 1.

In order to mark multiple arrays/pointers using ivdep on the same loop, then
multiple instances on `ivdep(array)` or `ivdep(array,safelen)` can be used. The
example below has the two arrays A and B marked with ivdep, but not C.
Additionally, we indicate that the minimum dependence distance on accesses of B
is 5 iterations.

```cpp
[[intel::ivdep(A)]]
[[intel::ivdep(B,5)]]
for(int i = 0; i <N; ++i) {
   A[i] += A[idx_A[i]];
   B[i] += B[idx_B[i]];
   C[i] += C[idx_C[i]];
}
```

### Marking parallel loops

In contrast with `ivdep`, which only deals with memory dependences, a new
language feature can be introduced to indicate that a loop is completely
parallel (i.e., in addition to memory data dependences, any memory-ordering
dependences can also be ignored). While we are not currently proposing this
feature, we mention it for completeness and because there is an existing LLVM IR
representation that has these semantics. If desired, it can be achieved using a
new annotation `[[intel::parallel]]`, a new lambda-style `parallel_for` API, or
using SYCL nested parallelism.

## LLVM Metadata changes

We are proposing the following new LLVM metadata:

1. A new metadata, `llvm.loop.no_depends`, should be generated on loops that are
   marked with the versions of `ivdep` that don't take a `safelen` (i.e.
   `intel::ivdep` and `intel::ivdep(array)`). It will replace the
   previously-generated `llvm.loop.parallel_access_indices` due to the mismatch
   in the semantics of `llvm.loop.paralllel_accesses` and `ivdep`. The semantics
   are that all accesses with access groups listed in this metadata have no
   loop-carried memory data dependences.
2. A new metadata, `llvm.loop.no_depends_safelen` should be generated on loops
   that are marked with the versions of ivdep that take a safelen (i.e.,
   `intel::ivdep(safelen)` and `intel::ivdep(array, safelen)`). It will replace our
   `llvm.loop.parallel_access_indices_safelen` for the same reason described
   above. As with `llvm.loop.no_depends`, the semantics indicate that all accesses
   with access groups listed in this metadata have dependence distances of at
   least safelen.
3. The built-in `llvm.loop.parallel_accesses` metadata semantics allow the
   compiler to not only ignore loop-carried data dependences, but also
   loop-carried memory-ordering dependences. This metadata should not be
   generated by the SYCL front end in conjunction with ivdep given the
   difference in their semantics. If a parallel loop feature is added in the
   future (as descirbed in [the previous section](#marking-parallel-loops)),
   then this metadata would be generated from that representation.
4. The built-in `llvm.access.group` metadata should be generated for all memory
   operations (loads, stores, and function calls) in the body of a loop that has
   either an ivdep attribute, or is marked as parallel (by the user or the
   compiler). The access group identifier will be passed to the corresponding
   loop metadata described above.

## SPIR-V Extension

The SPIR-V extension for this design doc is presented in #13918
(will update link to PR review is complete). This list
summarizes the additions:

1. Access groups defined using an LLVM `llvm.access.group` metadata are
represented as a literal in SPIR-V.
1. A new instruction `OpAccessGroupListINTEL` is used to aggregate multiple access groups
   into a single list.
2. A new Decoration `AccessGroupINTEL` is used to specify which access groups a
   function call or atomic instruction belongs to.
3. A new Memory Operand `AccessGroupMaskINTEL` is used to specify which access
   groups a memory operation belongs to.
4. Two new Loop Controls are added to represent `llvm.loop.parallel_accesses`
   and `llvm.loop.no_depends/no_depends_safelen`. They are called
   `ParallelAccessesINTEL` and `DependencyAccessesINTEL` accordingly.
   1. `ParallelAccessesINTEL` takes one or more `OpAccessGroupListINTEL` access group
      lists and specifies that for each list, all the accesses that belong to
      the specified access groups do not have loop-carried dependences.
   2. `DependencyAccessesINTEL` takes one or more pairs. The first element in
      each pair is a list of access groups from `OpAccessGroupListINTEL`, and the second
      element is an integer `S` that corresponds to the safelen. 

## Translation Rules

### SYCL to LLVM Metadata Translation

   1. For the different versions of ivdep:
      1. `[[intel::ivdep]]` on a loop should be translated to
         `llvm.access.group` metadata on all memory instructions and function
         calls in the loop body and the `llvm.loop.no_depends` metadata should
         be placed on the loop and passed the same access group(s). The front
         end is free to assign access groups as it sees fit as long as they all
         appear in the `llvm.loop.no_depends` metadata.
      2. `[[intel::ivdep(array)]]` on a loop should be translated to
         `llvm.access.group` metadata on all memory instructions that use the
         specified array, and `llvm.loop.no_depends` metadata should be placed
         on the loop and passed these access group(s). The front end is free to
         assign access groups as it sees fit as long as all the access groups
         for the accesses to the corresponding array appear in the
         `llvm.loop.no_depends` metadata. Multiple instances of `ivdep(array)`
         should generate a separate `llvm.loop.no_depends` metadata for each
         array.
      3. `[[intel::ivdep(safelen)]]` on a loop should be translated to
         `llvm.access.group` metadata on all memory instructions and function
         calls in the loop body and `llvm.loop.no_depends_safelen` metadata
         should be placed on the loop and passed the same access group(s) along
         with the safelen. The front end is free to assign access groups as it
         sees fit as long as they all appear in the
         `llvm.loop.no_depends_safelen` metadata. 
      4. `[[intel::ivdep(array, safelen)]]` should be translated to
        `llvm.access.group` metadata on all memory instructions that use the
        specified array, and `llvm.loop.no_depends_safelen` metadata should be
        placed on the loop and passed these access group(s). The front end is
        free to assign access groups as it sees fit as long as all the access
        groups for the accesses to the corresponding array appear in the
        `llvm.loop.no_depends_safelen` metadata. Multiple instances of
        ivdep(array, safelen) should generate a separate
        `llvm.loop.no_depends_safelen` metadata for each array.
      5. A few considerations:
         1. The front end is free to generate any access group and loop metadata
         it sees fit as long as it maintains the semantics that all the accesses
         that are independent (as indicated by the corresponding version of
         ivdep) have their access groups listed in the same loop metadata.  
         2. If overlapping attributes are detected (e.g. `intel::ivdep(a)` and
            `intel::ivdep(a,5)`) the front end is free to generate any or all
            metadata as it sees fit, and it must issue a warning to the user.
         3. In nested loops, outer loop metadata will have to take the access
           groups of both outer loop and inner loop accesses, but inner loop
           metadata will only take the inner loop accesses. This is to say that
           the access groups for inner loop accesses should be distinct from the
           access group for outer loop accesses that are not also in the inner
           loop.
   2. For parallel loops (if implemented in the future), the front end should
   generate `llvm.access.group` metadata on all the memory accesses and function
   calls in the loop body, and a `llvm.loop.parallel_accesses` on the loop with
   that access group(s) as argument. As with ivdep, in nested loops the outer
   loop will have the access groups of the accesses in the outer loop as well as
   the accesses in the inner loop, whereas the inner loop will only have the
   access groups of the inner loop accesses. Additionally, the frontend is free
   to generate the access groups as it sees fit, as long as all the access
   groups are provided to the same `llvm.loop.parallel_accesses` metadata.

### LLVM Metadata to SPIR-V-Friendly LLVM Metadata

Since the `llvm.loop.no_depends` and `llvm.loop.no_depends_safelen` metadata are
vendor-specific, they will need to be translated to a SPIR-V friendly format as
described in the Loop Controls section of the ["SPIRV Representation In
LLVM"](https://github.com/KhronosGroup/SPIRV-LLVM-Translator/blob/main/docs/SPIRVRepresentationInLLVM.rst)
document[^1]. This is done by using the following rules:

1. Each `llvm.loop.no_depends` is translated into a new
   `spirv.dependency_accesses` metadata attached to the same loop and with
   the same arguments as the original metadata. The last argument will be 0.
2. Each `llvm.loop.no_depends_safelen` is translated into a new
   `spirv.dependency_accesses` metadata attached the same loop and with the same
   arguments as the original metadata. This will also have the safelen as the
   last argument.

[^1] The convention for handling Loop Controls is introduced with PR [#2592](https://github.com/KhronosGroup/SPIRV-LLVM-Translator/pull/2592).

### LLVM Metadata to SPIR-V Translation

1. A new access group literal should be used for each distinct
   `llvm.access.group` metadata. If an `llvm.access.group` points to a
   collection of multiple distinct metadata, it should be decomposed into the
   individual literals accordingly.
2. Memory operations that have an assigned access group should get the
   `AccessGroupMaskINTEL` memory operand, along with the corresponding literals.
3. Atomic operations with assigned access group should get decorated using the
   `AccessGroupINTEL` decoration along with the corresponding literals.
4. For each instance of `spirv.dependency_accesses`, or
   `llvm.loop.parallel_accesses` on a given loop, a new `OpAccessGroupListINTEL`
   should be created to aggregate the access groups defined in the corresponding
   metadata. Each `OpAccessGroupListINTEL` will list the corresponding literals.
5. All `spirv.dependency_accesses` metadata on a single loop should get
   translated to one `DependencyAccessesINTEL` loop control. The first operand
   of the loop control will be the total number of metadata instances (e.g., if
   we combine two `spirv.dependency_accesses` into one `DependencyAccessesINTEL`
   then this will be `2`). Then, for each metadata instance, a pair should be
   constructed and provided to the loop control. This pair consists of the
   result of OpAccessGroupListINTEL for that metadata instance, and the last
   argument of that metadata instance, which is either 0 or an integer
   corresponding to the safelen.
6. All `llvm.loop.parallel_accesses` metadata on a single loop should get
   translated to one `ParallelAccessINTEL` loop control.  The first operand of
   the loop control will be the total number of metadata instances. Then, for
   each metadata instance, the corresponding aggregated access groups is
   provided to the loop control.

## Example

Consider the following example:

```cpp
[[intel::ivdep(A,C)]]
[[intel::ivdep(B,5)]]
for(int i = 0; i <N; ++i) {
   A[i] += A[idx_A[i]];
   B[i] += B[idx_B[i]];
   C[i] += C[idx_C[i]];
}
```

One way this could get translated to LLVM by the FE is shown below. Note that
the FE could have chosen to use the same access group for A and C.

```llvm
loop:
   %ld_A = load i32, ptr %A_idx !llvm.access.group !0
   %ld_Ai = load i32, ptr %A_i !llvm.access.group !0
   %sum_A = add i32 %ld_A, %ld_Ai
   store i32 %sum_A, ptr %A_i !llvm.access.group !0
   %ld_B = load i32, ptr %B_idx !llvm.access.group !1
   %ld_Bi = load i32, ptr %B_i !llvm.access.group !1
   %sum_B = add i32 %ld_B, %ld_Bi
   store i32 %sum_B, ptr %B_i !llvm.access.group !1
   %ld_C = load i32, ptr %C_idx !llvm.access.group !2
   %ld_Ci = load i32, ptr %C_i !llvm.access.group !2
   %sum_A = add i32 %ld_C, %ld_Ci
   store i32 %sum_C, ptr %C_i !llvm.access.group !2
   br ... %loop !llvm.loop.no_depends !4 !llvm.loop.no_depends_safelen !5

!0 = distinct !{}
!1 = distinct !{}
!2 = distinct !{}
!4 = !{!0, !2}
!5 = !{!1, 5}
```

This would become the following SPIR-V friendly LLVM IR:

```llvm
loop:
   %ld_A = load i32, ptr %A_idx !llvm.access.group !0
   %ld_Ai = load i32, ptr %A_i !llvm.access.group !0
   %sum_A = add i32 %ld_A, %ld_Ai
   store i32 %sum_A, ptr %A_i !llvm.access.group !0
   %ld_B = load i32, ptr %B_idx !llvm.access.group !1
   %ld_Bi = load i32, ptr %B_i !llvm.access.group !1
   %sum_B = add i32 %ld_B, %ld_Bi
   store i32 %sum_B, ptr %B_i !llvm.access.group !1
   %ld_C = load i32, ptr %C_idx !llvm.access.group !2
   %ld_Ci = load i32, ptr %C_i !llvm.access.group !2
   %sum_A = add i32 %ld_C, %ld_Ci
   store i32 %sum_C, ptr %C_i !llvm.access.group !2
   br ... %loop !spirv.loop.dependency_accesses !4 !spirv.loop.dependency_accesses !5

!0 = distinct !{}
!1 = distinct !{}
!2 = distinct !{}
!4 = !{!0, !2, 0}
!5 = !{!1, 5}
```

Finally, this will become the following SPIR-V:

```spirv
...
OpName %50 "loop"
OpName %51 "A_idx"
OpName %52 "A_i"
OpName %53 "B_idx"
OpName %54 "B_i"
OpName %55 "C_idx"
OpName %56 "C_i"
OpName %57 "ld_A"
OpName %58 "ld_Ai"
OpName %59 "sum_A"
OpName %60 "ld_B"
OpName %61 "ld_Bi"
OpName %62 "sum_B"
OpName %63 "ld_C"
OpName %64 "ld_Ci"
OpName %65 "sum_C"
...
%13 = OpTypeInt 32 1
...
%50 = OpLabel
%57 = OpLoad %13 %51 AccessGroupMaskINTEL 1 0 
%58 = OpLoad %13 %52 AccessGroupMaskINTEL 1 0
%59 = OpIAdd %13 %57 %58
OpStore %52 %59 AccessGroupMaskINTEL 1 0
%60 = OpLoad %13 %53 AccessGroupMaskINTEL 1 1 
%61 = OpLoad %13 %54 AccessGroupMaskINTEL 1 1
%62 = OpIAdd %13 %60 %61
OpStore %54 %62 AccessGroupMaskINTEL 1 1
%63 = OpLoad %13 %55 AccessGroupMaskINTEL 1 2
%64 = OpLoad %13 %56 AccessGroupMaskINTEL 1 2
%65 = OpIAdd %13 %63 %64
OpStore %56 %65 AccessGroupMaskINTEL 1 2
%66 = OpAccessGroupListINTEL 0 2
%67 = OpAccessGroupListINTEL 1
OpLoopMerge %50 %xx DependencyAccessesINTEL 2 %66 0 %67 5
```
