; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -passes='sycl-kernel-add-implicit-args,sycl-kernel-private-to-heap' -sycl-kernel-max-private-mem-size=1024 -S %s -enable-debugify -disable-output 2>&1 | FileCheck  -check-prefix=DEBUGIFY %s
; RUN: opt -passes='sycl-kernel-add-implicit-args,sycl-kernel-private-to-heap' -sycl-kernel-max-private-mem-size=1024 -S %s | FileCheck %s --check-prefixes CHECK,CHECK-IMP
; RUN: opt -passes='sycl-kernel-add-tls-globals,sycl-kernel-private-to-heap' -sycl-kernel-max-private-mem-size=1024 -S %s -enable-debugify -disable-output 2>&1 | FileCheck  -check-prefix=DEBUGIFY %s
; RUN: opt -passes='sycl-kernel-add-tls-globals,sycl-kernel-private-to-heap' -sycl-kernel-max-private-mem-size=1024 -S %s | FileCheck %s --check-prefixes CHECK,CHECK-TLS

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux"

define void @test(i64 %varsize) !no_barrier_path !7 !private_memory_size !8 {
  call void @foo(i64 %varsize)
  ret void
}

; Checks that PrivateToHeap doesn't generate illegal IR when a dynamic alloca is not in the entry block.
define void @foo(i64 %varsize) {
; CHECK-LABEL: define void @foo(
; CHECK-IMP-SAME: i64 [[VARSIZE:%.*]], ptr addrspace(3) noalias [[PLOCALMEMBASE:%.*]], ptr noalias [[PWORKDIM:%.*]], ptr noalias [[PWGID:%.*]], [4 x i64] [[BASEGLBID:%.*]], ptr noalias [[PSPECIALBUF:%.*]], ptr noalias [[RUNTIMEHANDLE:%.*]], ptr noalias [[PPRIVATEHEAPMEM:%.*]]) {
; CHECK-TLS-SAME: i64 [[VARSIZE:%.*]]) {
; CHECK-NEXT:    entry:
; CHECK-TLS-NEXT:  [[PPRIVATEHEAPMEM:%.*]] = load ptr, ptr @__pPrivateHeapMem, align 8
; CHECK-NEXT:      [[HEAPMEMOFFSETSTORAGE:%.*]] = alloca i64, align 8
; CHECK-NEXT:      store i64 0, ptr [[HEAPMEMOFFSETSTORAGE]], align 8
; CHECK-NEXT:      [[TMP0:%.*]] = icmp eq ptr [[PPRIVATEHEAPMEM]], null
; CHECK-NEXT:      [[CMP:%.*]] = icmp eq i64 [[VARSIZE]], 0
; CHECK-NEXT:      br i1 [[CMP]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK:         if:
; CHECK-NEXT:      [[TMP1:%.*]] = mul i64 1, [[VARSIZE]]
; CHECK-NEXT:      [[TMP2:%.*]] = add i64 [[TMP1]], 127
; CHECK-NEXT:      [[TMP3:%.*]] = and i64 [[TMP2]], -128
; CHECK-NEXT:      [[TMP4:%.*]] = load i64, ptr [[HEAPMEMOFFSETSTORAGE]], align 8
; CHECK-NEXT:      [[TMP5:%.*]] = select i1 [[TMP0]], i64 [[TMP3]], i64 0
; CHECK-NEXT:      [[TMP6:%.*]] = alloca i8, i64 [[TMP5]], align 1
; CHECK-NEXT:      [[TMP7:%.*]] = getelementptr i8, ptr [[PPRIVATEHEAPMEM]], i64 [[TMP4]]
; CHECK-NEXT:      [[TMP8:%.*]] = select i1 [[TMP0]], ptr [[TMP6]], ptr [[TMP7]]
; CHECK-NEXT:      [[TMP9:%.*]] = add i64 [[TMP4]], [[TMP3]]
; CHECK-NEXT:      store i64 [[TMP9]], ptr [[HEAPMEMOFFSETSTORAGE]], align 8
; CHECK-NEXT:      [[TMP10:%.*]] = load i64, ptr [[HEAPMEMOFFSETSTORAGE]], align 8
; CHECK-NEXT:      [[TMP11:%.*]] = getelementptr i8, ptr [[PPRIVATEHEAPMEM]], i64 [[TMP10]]
; CHECK-NEXT:      [[TMP12:%.*]] = select i1 [[TMP0]], ptr null, ptr [[TMP11]]
; CHECK-IMP-NEXT:  call void @bar(ptr [[TMP8]], ptr addrspace(3) noalias [[PLOCALMEMBASE]], ptr noalias [[PWORKDIM]], ptr noalias [[PWGID]], [4 x i64] [[BASEGLBID]], ptr noalias [[PSPECIALBUF]], ptr noalias [[RUNTIMEHANDLE]], ptr noalias [[TMP12]])
;
; CHECK-TLS-NEXT:  store ptr [[TMP12]], ptr @__pPrivateHeapMem, align 8
; CHECK-TLS-NEXT:  call void @bar(ptr [[TMP8]])
; CHECK-TLS-NEXT:  store ptr [[TMP12]], ptr @__pPrivateHeapMem, align 8
;
;;;;;; When the "if" branch is not taken, the offset loaded from HeapMemOffsetStorage should be 0,
;;;;;; which should not be affected by the allocation in the "if" branch.
;
; CHECK:         end:
; CHECK-NEXT:      [[TMP13:%.*]] = load i64, ptr [[HEAPMEMOFFSETSTORAGE]], align 8
; CHECK-NEXT:      [[TMP14:%.*]] = getelementptr i8, ptr [[PPRIVATEHEAPMEM]], i64 [[TMP13]]
; CHECK-NEXT:      [[TMP15:%.*]] = select i1 [[TMP0]], ptr null, ptr [[TMP14]]
; CHECK-IMP-NEXT:  call void @baz(i64 [[VARSIZE]], ptr addrspace(3) noalias [[PLOCALMEMBASE]], ptr noalias [[PWORKDIM]], ptr noalias [[PWGID]], [4 x i64] [[BASEGLBID]], ptr noalias [[PSPECIALBUF]], ptr noalias [[RUNTIMEHANDLE]], ptr noalias [[TMP15]])

; CHECK-TLS-NEXT:  store ptr [[TMP15]], ptr @__pPrivateHeapMem, align 8
; CHECK-TLS-NEXT:  call void @baz(i64 [[VARSIZE]])
; CHECK-TLS-NEXT:  store ptr [[TMP15]], ptr @__pPrivateHeapMem, align 8
entry:
  %cmp = icmp eq i64 %varsize, 0
  br i1 %cmp, label %if, label %else

if:
  %array = alloca i8, i64 %varsize, align 1
  call void @bar(ptr %array)
  br label %end

else:
  br label %end

end:
  call void @baz(i64 %varsize)
  ret void
}

define void @bar(ptr %array) {
  ret void
}

define void @baz(i64 %varsize) {
  ret void
}

!spirv.MemoryModel = !{!0}
!spirv.Source = !{!1}
!opencl.spir.version = !{!2}
!opencl.ocl.version = !{!2}
!spirv.Generator = !{!5}
!sycl.kernels = !{!6}

!0 = !{i32 2, i32 2}
!1 = !{i32 4, i32 200000}
!2 = !{i32 2, i32 0}
!5 = !{i16 6, i16 14}
!6 = !{ptr @test}
!7 = !{i1 true}
!8 = !{i32 8144}

; DEBUGIFY-NOT: WARNING
