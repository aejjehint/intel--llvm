; RUN: opt -passes='sycl-kernel-add-implicit-args,sycl-kernel-private-to-heap' -sycl-kernel-max-private-mem-size=1024 -S %s -enable-debugify -disable-output 2>&1 | FileCheck  -check-prefix=DEBUGIFY %s
; RUN: opt -passes='sycl-kernel-add-implicit-args,sycl-kernel-private-to-heap' -sycl-kernel-max-private-mem-size=1024 -S %s | FileCheck %s --check-prefixes CHECK,CHECK-IMP
; RUN: opt -passes='sycl-kernel-add-tls-globals,sycl-kernel-private-to-heap' -sycl-kernel-max-private-mem-size=1024 -S %s -enable-debugify -disable-output 2>&1 | FileCheck  -check-prefix=DEBUGIFY %s
; RUN: opt -passes='sycl-kernel-add-tls-globals,sycl-kernel-private-to-heap' -sycl-kernel-max-private-mem-size=1024 -S %s | FileCheck %s --check-prefixes CHECK,CHECK-TLS

; ----------------------------------------------------
; The test IR is generated by the code below
; ----------------------------------------------------
;void foo2(__global int *data, __private int* data2) {
;    __private int temp[2048];
;}
;void foo1(__global int *data1, __private int* data2) {
;    __private int temp1[2048];
;    foo2(data1, temp1);
;    __private int temp2[2048];
;    foo2(data1, temp2);
;}
;__kernel void test(__global int *data) {
;    __private int temp[2048];
;    foo1(data, temp);
;}

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux"

; Function Attrs: convergent noinline norecurse nounwind optnone
define dso_local void @foo2(ptr addrspace(1) noundef %data, ptr noundef %data2) #0 {
; CHECK-IMP-LABEL: define dso_local void @foo2(
; CHECK-IMP-SAME: ptr addrspace(1) noundef [[DATA:%.*]], ptr noundef [[DATA2:%.*]], ptr addrspace(3) noalias [[PLOCALMEMBASE:%.*]], ptr noalias [[PWORKDIM:%.*]], ptr noalias [[PWGID:%.*]], [4 x i64] [[BASEGLBID:%.*]], ptr noalias [[PSPECIALBUF:%.*]], ptr noalias [[RUNTIMEHANDLE:%.*]], ptr noalias [[PPRIVATEHEAPMEM:%.*]])

;;;;; load private heap memory address which is stored in  @__pPrivateHeapMem
; CHECK-TLS:    [[PPRIVATEHEAPMEM:%.*]] = load ptr, ptr @__pPrivateHeapMem, align 8

;;;;; alloca for "__private int temp[2048];" in foo2
; CHECK:         [[TMP0:%.*]] = icmp eq ptr [[PPRIVATEHEAPMEM]], null
; CHECK:         [[TMP1:%.*]] = select i1 [[TMP0]], i64 8192, i64 0
; CHECK:         [[TMP2:%.*]] = alloca i8, i64 [[TMP1]], align 4
; CHECK:         [[TMP3:%.*]] = getelementptr i8, ptr [[PPRIVATEHEAPMEM]], i64 0
; CHECK:         [[TMP4:%.*]] = select i1 [[TMP0]], ptr [[TMP2]], ptr [[TMP3]]
;
entry:
  %data.addr = alloca ptr addrspace(1), align 8
  %data2.addr = alloca ptr, align 8
  %temp = alloca [2048 x i32], align 4
  store ptr addrspace(1) %data, ptr %data.addr, align 8
  store ptr %data2, ptr %data2.addr, align 8
  ret void
}

; Function Attrs: convergent noinline norecurse nounwind optnone
define dso_local void @foo1(ptr addrspace(1) noundef %data1, ptr noundef %data2) #0 {
; CHECK-IMP-LABEL: void @foo1(
; CHECK-IMP-SAME: ptr addrspace(1) noundef [[DATA1:%.*]], ptr noundef [[DATA2:%.*]], ptr addrspace(3) noalias [[PLOCALMEMBASE:%.*]], ptr noalias [[PWORKDIM:%.*]], ptr noalias [[PWGID:%.*]], [4 x i64] [[BASEGLBID:%.*]], ptr noalias [[PSPECIALBUF:%.*]], ptr noalias [[RUNTIMEHANDLE:%.*]], ptr noalias [[PPRIVATEHEAPMEM:%.*]])
; CHECK-TLS-LABEL: void @foo1(
; CHECK-TLS-SAME: ptr addrspace(1) noundef [[DATA1:%.*]], ptr noundef [[DATA2:%.*]])

;;;;; load private heap memory address which is stored in  @__pPrivateHeapMem
; CHECK-TLS:     [[PPRIVATEHEAPMEM:%.*]] = load ptr, ptr @__pPrivateHeapMem, align 8

;;;;; alloca for "__private int temp1[2048];" in foo1
; CHECK:         [[TMP0:%.*]] = icmp eq ptr [[PPRIVATEHEAPMEM]], null
; CHECK:         [[TMP1:%.*]] = select i1 [[TMP0]], i64 8192, i64 0
; CHECK:         [[TMP2:%.*]] = alloca i8, i64 [[TMP1]], align 4
; CHECK:         [[TMP3:%.*]] = getelementptr i8, ptr [[PPRIVATEHEAPMEM]], i64 0
; CHECK:         [[TMP4:%.*]] = select i1 [[TMP0]], ptr [[TMP2]], ptr [[TMP3]]

;;;;; alloca for "__private int temp2[2048];" in foo1
; CHECK:         [[TMP5:%.*]] = select i1 [[TMP0]], i64 8192, i64 0
; CHECK:         [[TMP6:%.*]] = alloca i8, i64 [[TMP5]], align 4
; CHECK:         [[TMP7:%.*]] = getelementptr i8, ptr [[PPRIVATEHEAPMEM]], i64 8192
; CHECK:         [[TMP8:%.*]] = select i1 [[TMP0]], ptr [[TMP6]], ptr [[TMP7]]

;;;;; get the private heap memory current address with offset for the call foo2 in foo1
; CHECK:         [[TMP10:%.*]] = getelementptr i8, ptr [[PPRIVATEHEAPMEM]], i64 16384
; CHECK:         [[TMP11:%.*]] = select i1 [[TMP0]], ptr null, ptr [[TMP10]]

;;;;; in the entry, store heap's current address [[TMP11]] to @__pPrivateHeapMem
; CHECK-TLS:     store ptr [[TMP11]], ptr @__pPrivateHeapMem, align 8

;;;;; check if update the original implicit argument %pPrivateHeapMem of call foo2 with heap's current address [[TMP11]]
; CHECK-IMP:     call void @foo2(ptr addrspace(1) noundef [[ARG1:%.*]], ptr noundef [[ARG2:%.*]], ptr addrspace(3) noalias [[PLOCALMEMBASE]], ptr noalias [[PWORKDIM]], ptr noalias [[PWGID]], [4 x i64] [[BASEGLBID]], ptr noalias [[PSPECIALBUF]], ptr noalias [[RUNTIMEHANDLE]], ptr noalias [[TMP11]])
; CHECK-IMP:     call void @foo2(ptr addrspace(1) noundef [[ARG1:%.*]], ptr noundef [[ARG2:%.*]], ptr addrspace(3) noalias [[PLOCALMEMBASE]], ptr noalias [[PWORKDIM]], ptr noalias [[PWGID]], [4 x i64] [[BASEGLBID]], ptr noalias [[PSPECIALBUF]], ptr noalias [[RUNTIMEHANDLE]], ptr noalias [[TMP11]])

;;;;; after each call inst, recover heap address to @__pPrivateHeapMem
; CHECK-TLS:     call void @foo2(ptr addrspace(1) noundef [[ARG1:%.*]], ptr noundef [[ARG2:%.*]])
; CHECK-TLS:     store ptr [[TMP11]], ptr @__pPrivateHeapMem, align 8
; CHECK-TLS:     call void @foo2(ptr addrspace(1) noundef [[ARG1:%.*]], ptr noundef [[ARG2:%.*]])
; CHECK-TLS:     store ptr [[TMP11]], ptr @__pPrivateHeapMem, align 8

entry:
  %data1.addr = alloca ptr addrspace(1), align 8
  %data2.addr = alloca ptr, align 8
  %temp1 = alloca [2048 x i32], align 4
  %temp2 = alloca [2048 x i32], align 4
  store ptr addrspace(1) %data1, ptr %data1.addr, align 8
  store ptr %data2, ptr %data2.addr, align 8
  %0 = load ptr addrspace(1), ptr %data1.addr, align 8
  %arraydecay = getelementptr inbounds [2048 x i32], ptr %temp1, i64 0, i64 0
  call void @foo2(ptr addrspace(1) noundef %0, ptr noundef %arraydecay) #3
  %1 = load ptr addrspace(1), ptr %data1.addr, align 8
  %arraydecay1 = getelementptr inbounds [2048 x i32], ptr %temp2, i64 0, i64 0
  call void @foo2(ptr addrspace(1) noundef %1, ptr noundef %arraydecay1) #3
  ret void
}

; Function Attrs: convergent noinline norecurse nounwind optnone
define dso_local void @test(ptr addrspace(1) noundef align 4 %data) #1 !kernel_arg_addr_space !3 !kernel_arg_access_qual !4 !kernel_arg_type !5 !kernel_arg_base_type !5 !kernel_arg_type_qual !6 !kernel_arg_name !7 !kernel_arg_host_accessible !8 !kernel_arg_pipe_depth !9 !kernel_arg_pipe_io !6 !kernel_arg_buffer_location !6 !kernel_arg_target_ext_type !6 !no_barrier_path !10 !kernel_has_sub_groups !8 !kernel_has_global_sync !8 !kernel_execution_length !11 !private_memory_size !12 !barrier_buffer_size !9 !recommended_vector_length !3 {
; CHECK-IMP-LABEL: define dso_local void @test(
; CHECK-IMP-SAME: ptr addrspace(1) noundef align 4 [[DATA:%.*]], ptr addrspace(3) noalias [[PLOCALMEMBASE:%.*]], ptr noalias [[PWORKDIM:%.*]], ptr noalias [[PWGID:%.*]], [4 x i64] [[BASEGLBID:%.*]], ptr noalias [[PSPECIALBUF:%.*]], ptr noalias [[RUNTIMEHANDLE:%.*]], ptr noalias [[PPRIVATEHEAPMEM:%.*]])

; CHECK-TLS-LABEL: define dso_local void @test(
; CHECK-TLS-SAME: ptr addrspace(1) noundef align 4 [[DATA:%.*]]

; CHECK-TLS:     [[PPRIVATEHEAPMEM:%.*]] = load ptr, ptr @__pPrivateHeapMem, align 8

;;;;; alloca for "__private int temp[2048];" in test
; CHECK:         [[TMP0:%.*]] = icmp eq ptr [[PPRIVATEHEAPMEM]], null
; CHECK:         [[TMP1:%.*]] = select i1 [[TMP0]], i64 8192, i64 0
; CHECK:         [[TMP2:%.*]] = alloca i8, i64 [[TMP1]], align 4
; CHECK:         [[TMP3:%.*]] = getelementptr i8, ptr [[PPRIVATEHEAPMEM]], i64 0
; CHECK:         [[TMP4:%.*]] = select i1 [[TMP0]], ptr [[TMP2]], ptr [[TMP3]]

;;;;; prepare pPrivateHeapMem + offset for call foo1
; CHECK:         [[TMP5:%.*]] = getelementptr i8, ptr [[PPRIVATEHEAPMEM]], i64 8192
; CHECK:         [[TMP6:%.*]] = select i1 [[TMP0]], ptr null, ptr [[TMP5]]

;;;;; update the @__pPrivateHeapMem with [[TMP6]]
; CHECK-TLS:         store ptr [[TMP6]], ptr @__pPrivateHeapMem, align 8

;;;;; update the pPrivateHeapMem with [[TMP6]]
; CHECK-IMP:     call void @foo1(ptr addrspace(1) noundef [[TMP7:%.*]], ptr noundef [[ARRAYDECAY:%.*]], ptr addrspace(3) noalias [[PLOCALMEMBASE]], ptr noalias [[PWORKDIM]], ptr noalias [[PWGID]], [4 x i64] [[BASEGLBID]], ptr noalias [[PSPECIALBUF]], ptr noalias [[RUNTIMEHANDLE]], ptr noalias [[TMP6]]

;;;;; recover the @__pPrivateHeapMem with [[TMP6]] after the call
; CHECK-TLS:         call void @foo1(ptr addrspace(1) noundef [[TMP7:%.*]], ptr noundef [[ARRAYDECAY:%.*]])
; CHECK-TLS-NEXT:    store ptr [[TMP6]], ptr @__pPrivateHeapMem, align 8
;
entry:
  %data.addr = alloca ptr addrspace(1), align 8
  %temp = alloca [2048 x i32], align 4
  %lid = alloca i32, align 4
  %base.gid.dim0 = call i64 @get_base_global_id.(i32 0)
  %local.size.dim0 = call i64 @_Z14get_local_sizej(i32 0)
  %max.gid.dim0 = add i64 %base.gid.dim0, %local.size.dim0
  %base.gid.dim1 = call i64 @get_base_global_id.(i32 1)
  %local.size.dim1 = call i64 @_Z14get_local_sizej(i32 1)
  %max.gid.dim1 = add i64 %base.gid.dim1, %local.size.dim1
  %base.gid.dim2 = call i64 @get_base_global_id.(i32 2)
  %local.size.dim2 = call i64 @_Z14get_local_sizej(i32 2)
  %max.gid.dim2 = add i64 %base.gid.dim2, %local.size.dim2
  %dim_0_sub_lid = sub nuw nsw i64 %base.gid.dim0, %base.gid.dim0
  br label %dim_2_pre_head

dim_2_pre_head:                                   ; preds = %entry
  br label %dim_1_pre_head

dim_1_pre_head:                                   ; preds = %dim_1_exit, %dim_2_pre_head
  %dim_2_ind_var = phi i64 [ %base.gid.dim2, %dim_2_pre_head ], [ %dim_2_inc_ind_var, %dim_1_exit ]
  br label %dim_0_pre_head

dim_0_pre_head:                                   ; preds = %dim_0_exit, %dim_1_pre_head
  %dim_1_ind_var = phi i64 [ %base.gid.dim1, %dim_1_pre_head ], [ %dim_1_inc_ind_var, %dim_0_exit ]
  br label %scalar_kernel_entry

scalar_kernel_entry:                              ; preds = %scalar_kernel_entry, %dim_0_pre_head
  %dim_0_ind_var = phi i64 [ %base.gid.dim0, %dim_0_pre_head ], [ %dim_0_inc_ind_var, %scalar_kernel_entry ]
  %dim_0_tid = phi i64 [ %dim_0_sub_lid, %dim_0_pre_head ], [ %dim_0_inc_tid, %scalar_kernel_entry ]
  store ptr addrspace(1) %data, ptr %data.addr, align 8
  %conv = trunc i64 %dim_0_tid to i32
  store i32 %conv, ptr %lid, align 4
  %0 = load ptr addrspace(1), ptr %data.addr, align 8
  %arraydecay = getelementptr inbounds [2048 x i32], ptr %temp, i64 0, i64 0
  call void @foo1(ptr addrspace(1) noundef %0, ptr noundef %arraydecay) #3
  %dim_0_inc_ind_var = add nuw nsw i64 %dim_0_ind_var, 1
  %dim_0_cmp.to.max = icmp eq i64 %dim_0_inc_ind_var, %max.gid.dim0
  %dim_0_inc_tid = add nuw nsw i64 %dim_0_tid, 1
  br i1 %dim_0_cmp.to.max, label %dim_0_exit, label %scalar_kernel_entry

dim_0_exit:                                       ; preds = %scalar_kernel_entry
  %dim_1_inc_ind_var = add nuw nsw i64 %dim_1_ind_var, 1
  %dim_1_cmp.to.max = icmp eq i64 %dim_1_inc_ind_var, %max.gid.dim1
  br i1 %dim_1_cmp.to.max, label %dim_1_exit, label %dim_0_pre_head

dim_1_exit:                                       ; preds = %dim_0_exit
  %dim_2_inc_ind_var = add nuw nsw i64 %dim_2_ind_var, 1
  %dim_2_cmp.to.max = icmp eq i64 %dim_2_inc_ind_var, %max.gid.dim2
  br i1 %dim_2_cmp.to.max, label %dim_2_exit, label %dim_1_pre_head

dim_2_exit:                                       ; preds = %dim_1_exit
  br label %exit

exit:                                             ; preds = %dim_2_exit
  ret void
}

; Function Attrs: convergent nounwind willreturn memory(none)
declare i64 @_Z12get_local_idj(i32 noundef) #2

declare i64 @get_base_global_id.(i32)

declare i64 @_Z14get_local_sizej(i32)

attributes #0 = { convergent noinline norecurse nounwind optnone "no-trapping-math"="true" "prefer-vector-width"="512" "stack-protector-buffer-size"="8" "stackrealign" }
attributes #1 = { convergent noinline norecurse nounwind optnone "no-trapping-math"="true" "prefer-vector-width"="512" "stack-protector-buffer-size"="8" "stackrealign" "uniform-work-group-size"="true" }
attributes #2 = { convergent nounwind willreturn memory(none) "no-trapping-math"="true" "prefer-vector-width"="512" "stack-protector-buffer-size"="8" "stackrealign" }
attributes #3 = { convergent nounwind }

!llvm.linker.options = !{}
!opencl.ocl.version = !{!0}
!opencl.spir.version = !{!0}
!llvm.ident = !{!1}
!sycl.kernels = !{!2}

!0 = !{i32 1, i32 2}
!1 = !{!"Intel(R) oneAPI DPC++/C++ Compiler 2024.1.0 (2024.x.0.YYYYMMDD)"}
!2 = !{ptr @test}
!3 = !{i32 1}
!4 = !{!"none"}
!5 = !{!"int*"}
!6 = !{!""}
!7 = !{!"data"}
!8 = !{i1 false}
!9 = !{i32 0}
!10 = !{i1 true}
!11 = !{i32 11}
!12 = !{i32 32816}

; DEBUGIFY-NOT: WARNING
